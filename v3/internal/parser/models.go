package parser

import (
	"bytes"
	"embed"
	"fmt"
	"io"
	"path/filepath"
	"slices"
	"sort"
	"strings"
	"text/template"

	"github.com/gzuidhof/tygo/tygo"
	"github.com/wailsapp/wails/v3/internal/flags"
	"golang.org/x/exp/maps"
)

//go:embed templates
var templates embed.FS

type ModelDefinitions struct {
	Package string
	Models  map[string]*StructDef
	Enums   map[string]*TypeDef
	Imports []*ImportDef
}

func (p *Project) GenerateModel(wr io.Writer, def *ModelDefinitions, options *flags.GenerateBindingsOptions) error {
	templateName := "model.js.tmpl"
	if options.TS {
		templateName = "model.ts.tmpl"
		if options.UseInterfaces {
			templateName = "interfaces.ts.tmpl"
		}
	}

	// Fix up TS names
	for _, model := range def.Models {
		model.Name = options.TSPrefix + model.Name + options.TSSuffix
	}

	tmpl, err := template.New(templateName).ParseFS(templates, "templates/"+templateName)
	if err != nil {
		println("Unable to create class template: " + err.Error())
		return err
	}

	err = tmpl.ExecuteTemplate(wr, templateName, def)
	if err != nil {
		println("Problem executing template: " + err.Error())
		return err
	}
	return nil
}

const modelsHeader = `// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT
`

func pkgAlias(fullPkg string) string {
	pkgParts := strings.Split(fullPkg, "/")
	return pkgParts[len(pkgParts)-1]
}

type Model struct {
	Package string
}

func (p *Project) GenerateModels(models map[packagePath]map[structName]*StructDef, enums map[packagePath]map[string]*TypeDef, options *flags.GenerateBindingsOptions) (map[packagePath]string, error) {
	if models == nil && enums == nil {
		return nil, nil
	}
	var result = make(map[packagePath]string)

	// sort pkgs by alias (e.g. services) instead of full pkg name (e.g. github.com/wailsapp/wails/somedir/services)
	// and then sort resulting list by the alias
	var keys []string
	for pkg := range models {
		if !slices.Contains(keys, pkg) {
			keys = append(keys, pkg)
		}
	}
	for pkg := range enums {
		if !slices.Contains(keys, pkg) {
			keys = append(keys, pkg)
		}
	}

	sort.Slice(keys, func(i, j int) bool {
		return pkgAlias(keys[i]) < pkgAlias(keys[j])
	})

	for _, pkg := range keys {
		if options.UseTygo {
			var outputDir string
			path := pkg
			pkgInfo := p.packageCache[pkg]
			modelImports := p.calculateImports(pkg, models[pkg])
			imports := make(map[string]string)
			for _, i := range modelImports {
				var importPath string
				if strings.HasPrefix(pkgInfo.Dir, p.Path) {
					importPath = filepath.Join("..", i.Package.Path)
				} else {
					importPathParts := []string{}
					for _, _ = range strings.Split(filepath.ToSlash(pkgInfo.Path), "/") {
						importPathParts = append(importPathParts, "..")
					}

					importPathParts = append(importPathParts, strings.Split(filepath.ToSlash(i.Package.Path), "/")...)
					importPath = filepath.Join(importPathParts...)
				}

				imports[i.PackageName] = fmt.Sprintf("import * as %s from '%s';", i.PackageName, filepath.Join(importPath, "models.ts"))
			}

			if strings.HasPrefix(pkgInfo.Dir, p.Path) {
				outputDir = filepath.Join(options.OutputDirectory, pkgInfo.Name)
			} else {
				outputDir = filepath.Join(options.OutputDirectory, pkg)
			}

			cfg := &tygo.Config{
				Packages: []*tygo.PackageConfig{
					{
						Frontmatter:  strings.Join(maps.Values(imports), "\n"),
						Path:         path,
						OutputPath:   filepath.Join(outputDir, "models.ts"),
						FallbackType: "any",
					},
				},
			}
			gen := tygo.New(cfg)
			err := gen.Generate()
			if err != nil {
				return nil, err
			}
		} else {
			var buffer bytes.Buffer
			buffer.WriteString(modelsHeader)
			err := p.GenerateModel(&buffer, &ModelDefinitions{
				Imports: p.calculateImports(pkg, models[pkg]),
				Package: pkgAlias(pkg),
				Models:  models[pkg],
				Enums:   enums[pkg],
			}, options)
			if err != nil {
				return nil, err
			}

			relativePackageDir := p.RelativePackageDir(pkg)
			result[relativePackageDir] = buffer.String()
		}
	}
	return result, nil
}
